# GapAlign module
# used for galign.pl
# Chuan Wang @ Zhang's Lab

use strict;
use warnings;

@GapAlign::AA  = split(//, "ARNDCQEGHILKMFPSTWYVBJZX*");

# The BLOSUM62 amino acid substitution matrix

@GapAlign::BLOSUM62 =
    #  A  R  N  D  C  Q  E  G  H  I  L  K  M  F  P  S  T  W  Y  V  B  J  Z  X  *
  ( [  4,-1,-2,-2, 0,-1,-1, 0,-2,-1,-1,-1,-1,-2,-1, 1, 0,-3,-2, 0,-2,-1,-1,-1,-4],  # A
    [ -1, 5, 0,-2,-3, 1, 0,-2, 0,-3,-2, 2,-1,-3,-2,-1,-1,-3,-2,-3,-1,-2, 0,-1,-4],  # R
    [ -2, 0, 6, 1,-3, 0, 0, 0, 1,-3,-3, 0,-2,-3,-2, 1, 0,-4,-2,-3, 4,-3, 0,-1,-4],  # N
    [ -2,-2, 1, 6,-3, 0, 2,-1,-1,-3,-4,-1,-3,-3,-1, 0,-1,-4,-3,-3, 4,-3, 1,-1,-4],  # D
    [  0,-3,-3,-3, 9,-3,-4,-3,-3,-1,-1,-3,-1,-2,-3,-1,-1,-2,-2,-1,-3,-1,-3,-1,-4],  # C
    [ -1, 1, 0, 0,-3, 5, 2,-2, 0,-3,-2, 1, 0,-3,-1, 0,-1,-2,-1,-2, 0,-2, 4,-1,-4],  # Q
    [ -1, 0, 0, 2,-4, 2, 5,-2, 0,-3,-3, 1,-2,-3,-1, 0,-1,-3,-2,-2, 1,-3, 4,-1,-4],  # E
    [  0,-2, 0,-1,-3,-2,-2, 6,-2,-4,-4,-2,-3,-3,-2, 0,-2,-2,-3,-3,-1,-4,-2,-1,-4],  # G
    [ -2, 0, 1,-1,-3, 0, 0,-2, 8,-3,-3,-1,-2,-1,-2,-1,-2,-2, 2,-3, 0,-3, 0,-1,-4],  # H
    [ -1,-3,-3,-3,-1,-3,-3,-4,-3, 4, 2,-3, 1, 0,-3,-2,-1,-3,-1, 3,-3, 3,-3,-1,-4],  # I
    [ -1,-2,-3,-4,-1,-2,-3,-4,-3, 2, 4,-2, 2, 0,-3,-2,-1,-2,-1, 1,-4, 3,-3,-1,-4],  # L
    [ -1, 2, 0,-1,-3, 1, 1,-2,-1,-3,-2, 5,-1,-3,-1, 0,-1,-3,-2,-2, 0,-3, 1,-1,-4],  # K
    [ -1,-1,-2,-3,-1, 0,-2,-3,-2, 1, 2,-1, 5, 0,-2,-1,-1,-1,-1, 1,-3, 2,-1,-1,-4],  # M
    [ -2,-3,-3,-3,-2,-3,-3,-3,-1, 0, 0,-3, 0, 6,-4,-2,-2, 1, 3,-1,-3, 0,-3,-1,-4],  # F
    [ -1,-2,-2,-1,-3,-1,-1,-2,-2,-3,-3,-1,-2,-4, 7,-1,-1,-4,-3,-2,-2,-3,-1,-1,-4],  # P
    [  1,-1, 1, 0,-1, 0, 0, 0,-1,-2,-2, 0,-1,-2,-1, 4, 1,-3,-2,-2, 0,-2, 0,-1,-4],  # S
    [  0,-1, 0,-1,-1,-1,-1,-2,-2,-1,-1,-1,-1,-2,-1, 1, 5,-2,-2, 0,-1,-1,-1,-1,-4],  # T
    [ -3,-3,-4,-4,-2,-2,-3,-2,-2,-3,-2,-3,-1, 1,-4,-3,-2,11, 2,-3,-4,-2,-2,-1,-4],  # W
    [ -2,-2,-2,-3,-2,-1,-2,-3, 2,-1,-1,-2,-1, 3,-3,-2,-2, 2, 7,-1,-3,-1,-2,-1,-4],  # Y
    [  0,-3,-3,-3,-1,-2,-2,-3,-3, 3, 1,-2, 1,-1,-2,-2, 0,-3,-1, 4,-3, 2,-2,-1,-4],  # V
    [ -2,-1, 4, 4,-3, 0, 1,-1, 0,-3,-4, 0,-3,-3,-2, 0,-1,-4,-3,-3, 4,-3, 0,-1,-4],  # B
    [ -1,-2,-3,-3,-1,-2,-3,-4,-3, 3, 3,-3, 2, 0,-3,-2,-1,-2,-1, 2,-3, 3,-3,-1,-4],  # J
    [ -1, 0, 0, 1,-3, 4, 4,-2, 0,-3,-3, 1,-1,-3,-1, 0,-1,-2,-2,-2, 0,-3, 4,-1,-4],  # Z
    [ -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-4],  # X
    [ -4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4, 1]   # *
    #  A  R  N  D  C  Q  E  G  H  I  L  K  M  F  P  S  T  W  Y  V  B  J  Z  X  *
    );

# prediction accuracy of Psipred:
# Ppred[cf][B][A] = P(A,B,cf)/P(A)/P(B,cf) = P(A|B,cf)/P(A)
# A = observed ss state  B = predicted ss state  cf = confidence value of prediction
#float Ppred[MAXCF][NSSPRED][NDSSP]=
@GapAlign::Ppred =
  (
# pred/obs  -      H      E      ~      S      T      G      B
       [[1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000] , # - conf=-
        [1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000] , # H
        [1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000] , # E
        [1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000]] , # ~
       [[1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000] , # - conf=0
        [1.000, 1.128, 0.519, 0.834, 0.957, 1.488, 2.106, 1.085] , # H
        [1.000, 0.233, 2.240, 1.216, 0.913, 0.519, 0.923, 1.759] , # E
        [1.000, 0.640, 1.017, 1.122, 1.069, 1.242, 2.140, 1.999]] , # ~
       [[1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000] , # - conf=1
        [1.000, 1.251, 0.485, 0.771, 0.847, 1.371, 2.266, 0.864] , # H
        [1.000, 0.222, 2.542, 1.069, 0.804, 0.428, 0.671, 1.728] , # E
        [1.000, 0.474, 1.103, 1.295, 1.232, 1.214, 1.835, 1.989]] , # ~
       [[1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000] , # - conf=2
        [1.000, 1.383, 0.426, 0.637, 0.778, 1.349, 2.436, 0.824] , # H
        [1.000, 0.202, 2.769, 0.999, 0.714, 0.320, 0.551, 1.566] , # E
        [1.000, 0.395, 1.005, 1.407, 1.376, 1.336, 1.725, 2.063]] , # ~
       [[1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000] , # - conf=3
        [1.000, 1.531, 0.369, 0.552, 0.682, 1.280, 2.420, 0.698] , # H
        [1.000, 0.169, 2.970, 0.954, 0.556, 0.273, 0.489, 1.504] , # E
        [1.000, 0.352, 0.843, 1.515, 1.542, 1.456, 1.684, 1.958]] , # ~
       [[1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000] , # - conf=4
        [1.000, 1.750, 0.305, 0.444, 0.537, 1.134, 2.295, 0.600] , # H
        [1.000, 0.124, 3.179, 0.847, 0.513, 0.228, 0.413, 1.897] , # E
        [1.000, 0.282, 0.718, 1.664, 1.630, 1.577, 1.625, 1.877]] , # ~
       [[1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000] , # - conf=5
        [1.000, 1.952, 0.250, 0.353, 0.456, 0.982, 2.050, 0.466] , # H
        [1.000, 0.102, 3.464, 0.699, 0.453, 0.174, 0.284, 1.357] , # E
        [1.000, 0.227, 0.574, 1.782, 1.846, 1.681, 1.418, 1.885]] , # ~
       [[1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000] , # - conf=6
        [1.000, 2.183, 0.171, 0.263, 0.319, 0.792, 1.933, 0.345] , # H
        [1.000, 0.079, 3.712, 0.612, 0.281, 0.133, 0.196, 1.089] , # E
        [1.000, 0.173, 0.458, 1.915, 2.007, 1.766, 1.220, 1.704]] , # ~
       [[1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000] , # - conf=7
        [1.000, 2.389, 0.132, 0.192, 0.224, 0.605, 1.605, 0.183] , # H
        [1.000, 0.053, 3.997, 0.449, 0.201, 0.072, 0.141, 0.919] , # E
        [1.000, 0.109, 0.328, 2.013, 2.304, 1.882, 0.960, 1.512]] , # ~
       [[1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000] , # - conf=8
        [1.000, 2.668, 0.065, 0.098, 0.144, 0.354, 1.059, 0.102] , # H
        [1.000, 0.029, 4.285, 0.284, 0.113, 0.044, 0.059, 0.522] , # E
        [1.000, 0.053, 0.200, 2.099, 2.444, 2.133, 0.671, 1.290]] , # ~
       [[1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000] , # - conf=9
        [1.000, 2.966, 0.009, 0.023, 0.036, 0.113, 0.214, 0.017] , # H
        [1.000, 0.010, 4.555, 0.119, 0.027, 0.010, 0.013, 0.209] , # E
        [1.000, 0.026, 0.101, 2.576, 1.853, 2.204, 0.308, 0.499]]   # ~
  );

@GapAlign::Pobs = (0, 0.3268,0.2119,0.2061,0.0913,0.1143,0.0376,0.0120);


# The PSIPRED-PSIPRED score

sub sspred {
  # -0,H1,E2,~3 for B; 0-9 for cf
  my ($B, $cf, $BB, $ccf) = @_;
  $B =~ tr/-HEC~/01233/;
  $BB =~ tr/-HEC~/01233/;
  my $sum = 0;
  for (my $A=1; $A<8; $A++) {
    $sum += $GapAlign::Ppred[$cf][$B][$A] * $GapAlign::Ppred[$ccf][$BB][$A] * $GapAlign::Pobs[$A];
  }
  return log($sum)/log(2);
}


# The PSIPRED-PSIPRED score

sub ssprofile {
  my ($C, $H, $E, $CC, $HH, $EE) = @_;
  my $sum = $C*$CC + $H*$HH + $E*$EE;
  return $sum;
}

# The index of amino acids, 0-19, 20 for X

my %aaIndex;

for (my $i=0; $i<25; $i++) {
  $aaIndex{$GapAlign::AA[$i]} = $aaIndex{lc($GapAlign::AA[$i])} = $i;
}

# Background frequency of nr & nrdb90

# nrdb90
my @bgfreq = (0.07818, 0.05451, 0.04401, 0.05207, 0.01564,
  0.03845, 0.06320, 0.06840, 0.02240, 0.05827,
  0.09619, 0.05692, 0.02332, 0.04080, 0.04916,
  0.07318, 0.05556, 0.01255, 0.03131, 0.06591);

# The score of a pair of amino acids in a given matrix

sub score {
  # By ref,    val,  val,  val,val, ref,    ref
  my ($method, $aa1, $aa2, $i, $j, $lamdas, $pfls) = @_;
  my $score = 0;
  if ("ARNDCQEGHILKMFPSTWYVBJZX*" !~ /$aa1/) {
    $aa1 = "X";
  }
  if ("ARNDCQEGHILKMFPSTWYVBJZX*" !~ /$aa2/) {
    $aa2 = "X";
  }
  if ($method eq 'b62') {
    $score = $GapAlign::BLOSUM62[$aaIndex{$aa1}][$aaIndex{$aa2}];
  }else {
    #calculate vectors similarity
    my @s=@{$$pfls[0][$i]};
    my @t=@{$$pfls[1][$j]};
    if ($method eq 'dp') {
      for (0..19) {
        $score += $s[$_]*$t[$_];
      }
    } elsif ($method eq 'dp2') {
      @s = map {exp($_*$$lamdas[0])} @s;
      @t = map {exp($_*$$lamdas[1])} @t;
      for (0..19) {
        $score += $s[$_]*$t[$_];
      }
    } elsif ($method eq 'bdp') {
      for (0..19) {
        $score += $s[$_]*$t[$_];
      }
      $score = $GapAlign::BLOSUM62[$aaIndex{$aa1}][$aaIndex{$aa2}] + 55*$score;
    } elsif ($method eq 'bp') {
      for (0..19) {
        $score += $s[$_]*$t[$_];
      }
      my $wdp = .88;
      $score = (1-$wdp)*($GapAlign::BLOSUM62[$aaIndex{$aa1}][$aaIndex{$aa2}] + 4)*.0667 + $wdp*($score+1)*.5 - .472;
    } elsif ($method eq 'cc') {
      my ($up,$down1,$down2)=(0,0,0);
      for (0..19) {
        $up += $s[$_]*$t[$_];
        $down1 += $s[$_]**2;
        $down2 += $t[$_]**2;
      }
      $down1=1 if (!$down1 || $down1==0);
      $down2=1 if (!$down2 || $down2==0);
      $score = $up/sqrt($down1*$down2);
    } elsif ($method eq 'cc2') {
      @s = map {exp($_*$$lamdas[0])} @s;
      @t = map {exp($_*$$lamdas[1])} @t;
      my ($up,$down1,$down2)=(0,0,0);
      for (0..19) {
        $up += $s[$_]*$t[$_];
        $down1 += $s[$_]**2;
        $down2 += $t[$_]**2;
      }
      $down1=1 if (!$down1 || $down1==0);
      $down2=1 if (!$down2 || $down2==0);
      $score = $up/sqrt($down1*$down2);
    } elsif ($method eq 'pcc') {
      my ($est,$es,$et,$es2,$et2)=(0,0,0,0,0);
      for (0..19) {
        $est += $s[$_]*$t[$_];
        $es += $s[$_];
        $es2 += $s[$_]**2;
        $et += $t[$_];
        $et2 += $t[$_]**2;
      }
      my $down = ($es2-$es**2/20)*($et2-$et**2/20);
      $down = 1 if ($down == 0);
      $score = ($est-$es*$et/20)/sqrt($down);
    } elsif ($method eq 'bpc') {
      my ($est,$es,$et,$es2,$et2)=(0,0,0,0,0);
      for (0..19) {
        $est += $s[$_]*$t[$_];
        $es += $s[$_];
        $es2 += $s[$_]**2;
        $et += $t[$_];
        $et2 += $t[$_]**2;
      }
      my $down = ($es2-$es**2/20)*($et2-$et**2/20);
      $down = 1 if ($down == 0);
      $score = ($est-$es*$et/20)/sqrt($down);
      $score = $GapAlign::BLOSUM62[$aaIndex{$aa1}][$aaIndex{$aa2}] + 30*$score;
    } elsif ($method eq 'dpc') {
      my ($est,$es,$et,$es2,$et2)=(0,0,0,0,0);
      for (0..19) {
        $est += $s[$_]*$t[$_];
        $es += $s[$_];
        $es2 += $s[$_]**2;
        $et += $t[$_];
        $et2 += $t[$_]**2;
        $score += $s[$_]*$t[$_];
      }
      my $down = ($es2-$es**2/20)*($et2-$et**2/20);
      $down = 1 if ($down == 0);
      $score = ($est-$es*$et/20)/sqrt($down) + 30*$score;
    } elsif ($method eq 'pcc2') {
      @s = map {exp($_*$$lamdas[0])} @s;
      @t = map {exp($_*$$lamdas[1])} @t;
      my ($est,$es,$et,$es2,$et2)=(0,0,0,0,0);
      for (0..19) {
        $est += $s[$_]*$t[$_];
        $es += $s[$_];
        $es2 += $s[$_]**2;
        $et += $t[$_];
        $et2 += $t[$_]**2;
      }
      my $down = ($es2-$es**2/20)*($et2-$et**2/20);
      $down = 1 if ($down == 0);
      $score = ($est-$es*$et/20)/sqrt($down);
    } elsif ($method eq 'probs') {
      my (@sQ,@tQ);
      for (0..19) {
        $sQ[$_] = exp($s[$_]*$$lamdas[0])*$bgfreq[$_];
        $tQ[$_] = exp($t[$_]*$$lamdas[1])*$bgfreq[$_];
      }
      my ($sum1,$sum2)=(0,0);
      for (0..19) {
        $sum1 += $sQ[$_]*$t[$_]*$$lamdas[0];
        $sum2 += $tQ[$_]*$s[$_]*$$lamdas[1];
      }
      $score = $sum1+$sum2;
    } elsif ($method eq 'profsim') {
      for (0..19) {
        $s[$_] = exp($s[$_]*$$lamdas[0])*$bgfreq[$_];
        $t[$_] = exp($t[$_]*$$lamdas[1])*$bgfreq[$_];
      }
      my ($diver,$signi)=(0,0);
      for (0..19) {
        my $q0 = ($s[$_]+$t[$_])*.5;
        $diver += ( $s[$_]*log($s[$_]/$q0)/log(2) + $t[$_]*log($t[$_]/$q0)/log(2) ) *.5;
        my $r0 = ($q0+$bgfreq[$_])*.5;
        $signi += ( $q0*log($q0/$r0)/log(2) + $bgfreq[$_]*log($bgfreq[$_]/$r0)/log(2) ) *.5;
      }
      $score = .5*(1-$diver)*(1+$signi);
    }
  }
  return $score;
}

# The maximum of a list of numbers

sub max {
  my $res = shift;
  foreach (@_) {
    if ($_ > $res) {
      $res = $_;
    }
  }
  return $res;
}

# The minimum of a list of numbers

sub min {
  my $res = shift;
  foreach (@_) {
    if ($_ < $res) {
      $res = $_;
    }
  }
  return $res;
}

# The in array check

sub in_array {
    my ($arr,$search_for) = @_;
    foreach my $value (@$arr) {
        return 1 if $value eq $search_for;
    }
    return 0;
}

# The transform of E-value to Henikoff weight

sub transform {
    my $ev = shift;
    my $yw;
    if($ev<1e-10)
    {
	$yw=1.0;
    }
    elsif($ev<1e-9)
    {
	$yw=0.95; #0.95;
    }
    elsif($ev<1e-8)
    {
	$yw=0.90; #0.92;
    }
    elsif($ev<1e-7)
    {
	$yw=0.85; #0.90;
    }
    elsif($ev<1e-6)
    {
	$yw=0.8; #0.87;
    }
    elsif($ev<1e-5)
    {
	$yw=0.75 #0.85;
    }
    elsif($ev<1e-4)
    {
	$yw=0.70;
    }
    elsif($ev<1e-3)
    {
	$yw=0.65;
    }
    elsif($ev<1e-2)
    {
	$yw=0.60;
    }
    elsif($ev<1e-1)
    {
	$yw=0.55;
    }
    elsif($ev<1)
    {
	$yw=0.50;
    }
    return $yw;
}

1;   # Necessary for this module to load into scripts that use it.
